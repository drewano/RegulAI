"""
Application Streamlit pour RegulAI - Assistant Juridique IA.

Cette application fournit une interface web pour interagir avec l'agent RegulAI,
sp√©cialis√© dans la recherche juridique fran√ßaise.
"""

import streamlit as st
import os
import uuid
import traceback
from typing import Optional, Dict, Any, Generator

# Configuration de la page
st.set_page_config(
    page_title="RegulAI - Assistant Juridique",
    page_icon="‚öñÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# ============================================
# FONCTIONS UTILITAIRES
# ============================================

def generate_thread_id() -> str:
    """G√©n√®re un identifiant unique pour la conversation."""
    return f"streamlit-session-{uuid.uuid4().hex[:8]}"


def get_api_key_from_sources() -> tuple[Optional[str], str]:
    """
    R√©cup√®re la cl√© API Google depuis diff√©rentes sources.
    
    Returns:
        tuple: (cl√©_api, source) o√π source indique d'o√π vient la cl√©
    """
    # V√©rifier les secrets Streamlit
    try:
        api_key_from_secrets = st.secrets.get("GOOGLE_API_KEY")
        if api_key_from_secrets:
            return api_key_from_secrets, "secrets.toml"
    except (KeyError, FileNotFoundError):
        pass
    
    # V√©rifier les variables d'environnement
    api_key_from_env = os.getenv("GOOGLE_API_KEY")
    if api_key_from_env:
        return api_key_from_env, "variables d'environnement"
    
    return None, "non trouv√©e"


def mask_api_key(api_key: str) -> str:
    """Masque la cl√© API pour l'affichage s√©curis√©."""
    if len(api_key) > 12:
        return f"{api_key[:8]}...{api_key[-4:]}"
    return "cl√© trop courte"


# ============================================
# GESTION DES ERREURS ET VALIDATION
# ============================================

def test_mcp_server_connection() -> tuple[bool, str]:
    """
    Test la connexion au serveur MCP.
    
    Returns:
        tuple: (succ√®s, message_status)
    """
    try:
        from src.regulai.tools import test_mcp_connection
        is_connected = test_mcp_connection()
        if is_connected:
            return True, "‚úÖ Serveur MCP accessible"
        else:
            return False, "‚ùå Serveur MCP non accessible"
    except ImportError:
        return False, "‚ùå Modules RegulAI non disponibles"
    except Exception as e:
        return False, f"‚ùå Erreur de connexion MCP : {str(e)}"


def validate_agent_configuration() -> tuple[bool, str]:
    """
    Valide la configuration de l'agent.
    
    Returns:
        tuple: (valide, message_status)
    """
    try:
        from src.regulai.config import get_config
        config = get_config()
        return True, "‚úÖ Configuration valid√©e"
    except Exception as e:
        return False, f"‚ùå Erreur de configuration : {str(e)}"


# ============================================
# INITIALISATION ET CACHE DE L'AGENT
# ============================================

@st.cache_resource
def initialize_agent(google_api_key: str):
    """
    Initialise l'agent RegulAI une seule fois et le met en cache.
    
    Args:
        google_api_key: Cl√© API Google pour l'initialisation
        
    Returns:
        Agent LangGraph compil√© ou None en cas d'erreur
    """
    try:
        # Configurer temporairement la cl√© API dans l'environnement
        os.environ["GOOGLE_API_KEY"] = google_api_key
        
        # Import et cr√©ation de l'agent
        from src.regulai.agent import create_agent
        agent = create_agent()
        
        return agent
    except ImportError as e:
        st.error(f"‚ùå Erreur d'import des modules RegulAI : {e}")
        return None
    except Exception as e:
        st.error(f"‚ùå Erreur lors de l'initialisation de l'agent : {e}")
        return None


# ============================================
# TRAITEMENT DU STREAMING
# ============================================

def process_streaming_events(stream_generator) -> Generator[str, None, None]:
    """
    Traite les √©v√©nements de streaming de l'agent pour afficher les √©tapes interm√©diaires.
    
    Args:
        stream_generator: G√©n√©rateur d'√©v√©nements de streaming de l'agent (mode "updates")
        
    Yields:
        str: Contenu √† afficher pour le streaming de texte
        
    Cette fonction intercepte les √©v√©nements de streaming pour:
    - D√©tecter les appels d'outils et afficher un indicateur de statut
    - Permettre l'affichage des √©tapes interm√©diaires de l'agent
    - Maintenir la compatibilit√© avec st.write_stream
    """
    active_statuses = {}  # Pour traquer les statuses actifs par outil
    last_content = ""  # Pour √©viter la duplication de contenu
    
    try:
        for event in stream_generator:
            # Les √©v√©nements en mode "updates" sont des dictionnaires avec des cl√©s de n≈ìuds
            if isinstance(event, dict):
                # Parcourir chaque n≈ìud dans l'√©v√©nement
                for node_name, node_data in event.items():
                    # V√©rifier s'il y a des messages dans les donn√©es du n≈ìud
                    if isinstance(node_data, dict) and "messages" in node_data:
                        messages = node_data["messages"]
                        if messages:
                            last_message = messages[-1]
                            
                            # D√©tecter les appels d'outils dans les messages AI (n≈ìud "agent")
                            if node_name == "agent" and hasattr(last_message, 'tool_calls') and last_message.tool_calls:
                                for tool_call in last_message.tool_calls:
                                    tool_name = tool_call.get('name', 'outil_inconnu')
                                    tool_id = tool_call.get('id', f'tool_{len(active_statuses)}')
                                    
                                    # Mapper les noms d'outils vers des messages plus conviviaux
                                    tool_display_names = {
                                        'search_legifrance': 'üîç Recherche sur L√©gifrance...',
                                        'get_article': 'üìÑ R√©cup√©ration d\'article juridique...',
                                        'browse_code': 'üìö Navigation dans le code juridique...',
                                    }
                                    
                                    status_message = tool_display_names.get(tool_name, f'‚öôÔ∏è Ex√©cution de {tool_name}...')
                                    
                                    # Cr√©er un indicateur de statut pour cet outil
                                    if tool_id not in active_statuses:
                                        active_statuses[tool_id] = st.status(status_message, expanded=False)
                            
                            # D√©tecter les r√©ponses d'outils (n≈ìud "tools")
                            elif node_name == "tools" and hasattr(last_message, 'tool_call_id'):
                                tool_call_id = last_message.tool_call_id
                                # Fermer le statut correspondant s'il existe
                                if tool_call_id in active_statuses:
                                    status = active_statuses[tool_call_id]
                                    status.update(label="‚úÖ Termin√©", state="complete")
                                    # Retirer de la liste des statuses actifs
                                    del active_statuses[tool_call_id]
                            
                            # Si c'est un message de r√©ponse finale de l'agent (sans appels d'outils)
                            elif (node_name == "agent" and 
                                  hasattr(last_message, 'content') and 
                                  last_message.content and
                                  not (hasattr(last_message, 'tool_calls') and last_message.tool_calls)):
                                
                                # Yielder seulement le nouveau contenu pour √©viter la duplication
                                current_content = last_message.content
                                if current_content != last_content:
                                    # Yield le contenu complet (st.write_stream g√®re l'affichage progressif)
                                    yield current_content
                                    last_content = current_content
            else:
                # Si ce n'est pas un √©v√©nement structur√© attendu, essayer de le traiter comme du texte
                content_str = str(event) if event else ""
                if content_str and content_str.strip() and content_str != last_content:
                    yield content_str
                    last_content = content_str
    
    except Exception as e:
        yield f"‚ùå Erreur lors du traitement du streaming : {str(e)}"


# ============================================
# GESTION DE LA CONVERSATION
# ============================================

def handle_user_message(prompt: str, agent) -> Optional[str]:
    """
    Traite un message utilisateur et retourne la r√©ponse de l'agent.
    
    Args:
        prompt: Message de l'utilisateur
        agent: Instance de l'agent RegulAI
        
    Returns:
        R√©ponse de l'agent ou None en cas d'erreur
    """
    try:
        # Import de la fonction de streaming
        from src.regulai.agent import stream_agent_conversation
        
        # Cr√©er le g√©n√©rateur de streaming pour l'agent RegulAI avec d√©tection d'outils
        raw_stream_generator = stream_agent_conversation(
            message=prompt,
            thread_id=st.session_state.thread_id,
            agent=agent
        )
        
        # Traiter les √©v√©nements pour afficher les statuts d'outils
        processed_stream = process_streaming_events(raw_stream_generator)
        
        # Utiliser st.write_stream pour afficher la r√©ponse en temps r√©el
        # st.write_stream consomme le g√©n√©rateur et retourne le contenu complet
        response_content = st.write_stream(processed_stream)
        
        # S'assurer que le retour est toujours une cha√Æne
        if isinstance(response_content, list):
            return "\n".join(str(item) for item in response_content)
        elif response_content is not None:
            return str(response_content)
        else:
            return None
        
    except ImportError as e:
        st.error(f"‚ùå Erreur d'import : {e}")
        return None
    except Exception as e:
        st.error(f"‚ùå Erreur lors du traitement de votre demande : {str(e)}")
        st.error("üí° V√©rifiez votre configuration et r√©essayez.")
        return None


def reset_conversation():
    """R√©initialise compl√®tement la conversation."""
    if "messages" in st.session_state:
        st.session_state.messages = []
    
    # G√©n√©rer un nouveau thread_id pour une nouvelle conversation
    st.session_state.thread_id = generate_thread_id()
    
    # Remettre le message de bienvenue
    welcome_message = {
        "role": "assistant", 
        "content": "Bonjour ! Je suis RegulAI, votre assistant juridique sp√©cialis√© dans le droit fran√ßais. Comment puis-je vous aider aujourd'hui ?"
    }
    st.session_state.messages.append(welcome_message)


# ============================================
# COMPOSANTS DE L'INTERFACE
# ============================================

def render_welcome_section():
    """Affiche la section de bienvenue."""
    st.title("‚öñÔ∏è RegulAI - Assistant Juridique")
    st.subheader("ü§ñ Votre assistant IA sp√©cialis√© en recherche juridique fran√ßaise")
    
    st.markdown("""
    ---
    ### Bienvenue sur RegulAI !

    RegulAI est un assistant IA intelligent sp√©cialis√© dans la recherche juridique fran√ßaise. 
    Il utilise l'architecture LangGraph et des outils MCP pour vous fournir des r√©ponses pr√©cises 
    et actualis√©es sur le droit fran√ßais.

    **Fonctionnalit√©s principales :**
    - üîç Recherche juridique avanc√©e
    - üìö Acc√®s aux bases de donn√©es l√©gales
    - üéØ R√©ponses contextuelles et pr√©cises
    - üí¨ Interface conversationnelle intuitive

    ---
    """)


def render_api_key_configuration():
    """
    G√®re la configuration de la cl√© API Google dans la sidebar.
    
    Returns:
        bool: True si la cl√© API est configur√©e, False sinon
    """
    st.subheader("üîë Cl√© API Google")
    
    # V√©rifier les sources existantes
    api_key_from_sources, source = get_api_key_from_sources()
    
    # Initialiser la session state pour la cl√© API
    if "google_api_key" not in st.session_state:
        st.session_state.google_api_key = api_key_from_sources or ""
    
    # Champ de saisie de la cl√© API (type password pour la s√©curit√©)
    user_api_key = st.text_input(
        label="Entrez votre cl√© API Google :",
        type="password",
        value=st.session_state.google_api_key if source == "non trouv√©e" else "",
        placeholder="AI..." if source == "non trouv√©e" else f"Cl√© configur√©e via {source}",
        help="Votre cl√© API sera stock√©e de mani√®re s√©curis√©e dans la session.",
        disabled=bool(source != "non trouv√©e"),
        key="api_key_input"
    )
    
    # Mettre √† jour la session state si l'utilisateur a saisi une cl√©
    if user_api_key and source == "non trouv√©e":
        st.session_state.google_api_key = user_api_key
    
    # Affichage du statut de la cl√© API
    if st.session_state.google_api_key:
        if source != "non trouv√©e":
            st.success(f"‚úÖ Cl√© API charg√©e depuis {source}")
        else:
            st.success("‚úÖ Cl√© API saisie par l'utilisateur")
        
        # Masquer la cl√© (afficher seulement les premiers et derniers caract√®res)
        masked_key = mask_api_key(st.session_state.google_api_key)
        st.caption(f"üîí Cl√© active : `{masked_key}`")
        
        return True
    else:
        st.error("‚ùå Aucune cl√© API configur√©e")
        return False


def render_system_status():
    """Affiche l'√©tat du syst√®me dans la sidebar."""
    st.header("üìã √âtat du syst√®me")
    
    # V√©rifier la configuration
    config_valid, config_msg = validate_agent_configuration()
    
    # V√©rifier la connexion MCP
    mcp_connected, mcp_msg = test_mcp_server_connection()
    
    # √âtat de l'agent
    agent_status = "‚ùå Non initialis√©"
    if st.session_state.get("google_api_key"):
        try:
            agent = initialize_agent(st.session_state.google_api_key)
            agent_status = "‚úÖ Op√©rationnel" if agent else "‚ùå Erreur d'initialisation"
        except:
            agent_status = "‚ùå Erreur d'initialisation"
    
    st.markdown(f"""
    **Version :** 0.2.0
    
    **√âtat des composants :**
    - üîß Configuration : {config_msg}
    - ü§ñ Agent RegulAI : {agent_status}
    - üîó Serveur MCP : {mcp_msg}
    - ‚úÖ Interface Streamlit : Op√©rationnelle
    
    **Besoin d'aide ?**
    - üìñ Documentation dans le README
    - üîß Exemples dans `/examples`
    - üîë [Obtenir une cl√© API Google](https://aistudio.google.com/app/apikey)
    """)


def render_conversation_actions():
    """Affiche les actions de conversation dans la sidebar."""
    if not st.session_state.get("google_api_key"):
        return
    
    st.subheader("üí¨ Actions")
    
    col1, col2 = st.columns(2)
    
    # Bouton pour nouvelle conversation
    with col1:
        if st.button("üÜï Nouvelle", help="D√©marrer une nouvelle conversation", type="primary"):
            reset_conversation()
            st.rerun()
    
    # Bouton pour r√©initialiser l'agent
    with col2:
        if st.button("üîÑ Reset Agent", help="R√©initialiser l'agent en cas de probl√®me", type="secondary"):
            # Vider le cache de l'agent pour le forcer √† se r√©initialiser
            initialize_agent.clear()
            st.rerun()
    
    # Afficher les informations de session
    if "messages" in st.session_state:
        msg_count = len(st.session_state.messages)
        st.caption(f"üìù Messages : {msg_count}")
    
    if "thread_id" in st.session_state:
        st.caption(f"üîó Session : `{st.session_state.thread_id}`")
    
    # Indicateur de streaming
    st.caption("üí¨ Mode streaming activ√©")


def render_chat_interface():
    """Affiche l'interface de chat principale."""
    # Initialiser l'identifiant de conversation unique
    if "thread_id" not in st.session_state:
        st.session_state.thread_id = generate_thread_id()
    
    # Initialiser l'historique de conversation dans session_state
    if "messages" not in st.session_state:
        st.session_state.messages = []
        # Message de bienvenue
        welcome_message = {
            "role": "assistant", 
            "content": "Bonjour ! Je suis RegulAI, votre assistant juridique sp√©cialis√© dans le droit fran√ßais. Comment puis-je vous aider aujourd'hui ?"
        }
        st.session_state.messages.append(welcome_message)
    
    # Afficher l'historique des messages
    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])
    
    # Champ de saisie pour les nouveaux messages
    if prompt := st.chat_input("Posez votre question juridique..."):
        # Ajouter le message utilisateur √† l'historique
        user_message = {"role": "user", "content": prompt}
        st.session_state.messages.append(user_message)
        
        # Afficher le message utilisateur
        with st.chat_message("user"):
            st.markdown(prompt)
        
        # Obtenir l'agent initialis√©
        try:
            agent = initialize_agent(st.session_state.google_api_key)
            
            if agent:
                # Afficher la r√©ponse de l'agent avec streaming et statut des outils
                with st.chat_message("assistant"):
                    response_content = handle_user_message(prompt, agent)
                    
                    if response_content:
                        # Ajouter la r√©ponse √† l'historique
                        assistant_message = {"role": "assistant", "content": response_content}
                        st.session_state.messages.append(assistant_message)
                    else:
                        # En cas d'erreur, ajouter un message d'erreur g√©n√©rique
                        error_msg = "‚ùå Impossible de traiter votre demande. Veuillez r√©essayer."
                        st.markdown(error_msg)
                        assistant_message = {"role": "assistant", "content": error_msg}
                        st.session_state.messages.append(assistant_message)
            else:
                # Agent non initialis√© - afficher un message d'erreur
                error_msg = "‚ùå **Agent non disponible**\n\nL'agent RegulAI n'a pas pu √™tre initialis√©. V√©rifiez votre cl√© API Google."
                
                with st.chat_message("assistant"):
                    st.markdown(error_msg)
                
                assistant_message = {"role": "assistant", "content": error_msg}
                st.session_state.messages.append(assistant_message)
                
        except Exception as e:
            # Erreur g√©n√©rale d'initialisation
            error_msg = f"‚ùå **Erreur syst√®me**\n\n{str(e)}"
            
            with st.chat_message("assistant"):
                st.markdown(error_msg)
            
            assistant_message = {"role": "assistant", "content": error_msg}
            st.session_state.messages.append(assistant_message)


def render_configuration_warning():
    """Affiche les instructions de configuration si n√©cessaire."""
    st.warning("""
    ‚ö†Ô∏è **Configuration requise**
    
    Pour utiliser RegulAI, vous devez configurer votre cl√© API Google. 
    
    **Options de configuration :**
    
    1. **Via la barre lat√©rale** ‚Üê Saisissez votre cl√© dans le champ √† gauche
    2. **Via un fichier secrets.toml** ‚Üê Cr√©ez `.streamlit/secrets.toml` :
       ```toml
       GOOGLE_API_KEY = "AI-votre-cl√©-ici"
       ```
    3. **Via les variables d'environnement** ‚Üê D√©finissez `GOOGLE_API_KEY`
    
    [üîó Obtenir une cl√© API Google](https://aistudio.google.com/app/apikey)
    """)
    
    st.info("üí° **Votre cl√© API est s√©curis√©e** - Elle est stock√©e uniquement dans votre session et jamais transmise ailleurs que vers l'API Google.")


# ============================================
# APPLICATION PRINCIPALE
# ============================================

def main():
    """Fonction principale de l'application."""
    try:
        # Afficher la section de bienvenue
        render_welcome_section()
        
        # Sidebar - Configuration et √©tat
        with st.sidebar:
            st.header("üîß Configuration")
            
            # Configuration de la cl√© API
            api_key_configured = render_api_key_configuration()
            
            st.divider()
            
            # Actions de conversation
            render_conversation_actions()
            
            st.divider()
            
            # √âtat du syst√®me
            render_system_status()
        
        # Interface principale
        if not api_key_configured:
            render_configuration_warning()
        else:
            st.success("‚úÖ Configuration termin√©e ! Vous pouvez maintenant commencer √† converser avec RegulAI.")
            render_chat_interface()
    
    except Exception as e:
        st.error(f"‚ùå **Erreur critique de l'application**")
        st.error(f"D√©tails : {str(e)}")
        
        # Afficher la stack trace en mode d√©veloppement
        if st.checkbox("üîß Afficher les d√©tails techniques", help="Pour le debugging"):
            st.code(traceback.format_exc())
        
        st.info("üí° Essayez de recharger la page ou contactez le support si le probl√®me persiste.")


if __name__ == "__main__":
    main() 