#!/usr/bin/env python3
"""
Script de lancement principal pour RegulAI.

Ce script lance s√©quentiellement :
1. Le serveur MCP (services/mcp/main.py) en arri√®re-plan
2. V√©rifie que le serveur MCP est op√©rationnel via health check
3. Lance l'application Streamlit une fois le serveur MCP pr√™t

Usage:
    python start.py [--host HOST] [--port PORT] [--mcp-port MCP_PORT] [--timeout TIMEOUT]
"""

import asyncio
import atexit
import argparse
import os
import signal
import subprocess
import sys
import time
from pathlib import Path
from typing import Optional

import httpx


class RegulAILauncher:
    """Lanceur principal pour RegulAI - g√®re le serveur MCP et l'application Streamlit."""
    
    def __init__(
        self,
        host: str = "127.0.0.1",
        streamlit_port: int = 8501,
        mcp_port: int = 8000,
        health_check_timeout: int = 30,
        health_check_interval: float = 1.0
    ):
        """
        Initialise le lanceur.
        
        Args:
            host: Adresse d'√©coute pour les serveurs
            streamlit_port: Port pour l'application Streamlit
            mcp_port: Port pour le serveur MCP
            health_check_timeout: Timeout total pour le health check (secondes)
            health_check_interval: Intervalle entre les tentatives de health check (secondes)
        """
        self.host = host
        self.streamlit_port = streamlit_port
        self.mcp_port = mcp_port
        self.health_check_timeout = health_check_timeout
        self.health_check_interval = health_check_interval
        
        # R√©f√©rences vers les processus
        self.mcp_process: Optional[subprocess.Popen] = None
        self.streamlit_process: Optional[subprocess.Popen] = None
        
        # URLs des services
        self.mcp_url = f"http://{host}:{mcp_port}"
        self.streamlit_url = f"http://{host}:{streamlit_port}"
        
        # Registrer le nettoyage automatique
        atexit.register(self.cleanup)
        
        # Gestionnaire de signaux pour un arr√™t propre
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        """Gestionnaire de signal pour arr√™t propre."""
        print(f"\nüõë Signal {signum} re√ßu, arr√™t en cours...")
        self.cleanup()
        sys.exit(0)
    
    def cleanup(self):
        """Nettoie les processus en cours."""
        print("üßπ Nettoyage des processus...")
        
        # Arr√™ter Streamlit en premier (moins critique)
        if self.streamlit_process and self.streamlit_process.poll() is None:
            print("   ‚èπÔ∏è  Arr√™t de Streamlit...")
            try:
                self.streamlit_process.terminate()
                self.streamlit_process.wait(timeout=5)
                print("   ‚úÖ Streamlit arr√™t√©")
            except subprocess.TimeoutExpired:
                print("   ‚ö†Ô∏è  Timeout - for√ßage de l'arr√™t de Streamlit")
                self.streamlit_process.kill()
                self.streamlit_process.wait()
            except Exception as e:
                print(f"   ‚ùå Erreur lors de l'arr√™t de Streamlit: {e}")
        
        # Arr√™ter le serveur MCP
        if self.mcp_process and self.mcp_process.poll() is None:
            print("   ‚èπÔ∏è  Arr√™t du serveur MCP...")
            try:
                self.mcp_process.terminate()
                self.mcp_process.wait(timeout=5)
                print("   ‚úÖ Serveur MCP arr√™t√©")
            except subprocess.TimeoutExpired:
                print("   ‚ö†Ô∏è  Timeout - for√ßage de l'arr√™t du serveur MCP")
                self.mcp_process.kill()
                self.mcp_process.wait()
            except Exception as e:
                print(f"   ‚ùå Erreur lors de l'arr√™t du serveur MCP: {e}")
    
    def _get_python_executable(self) -> str:
        """Trouve l'ex√©cutable Python appropri√©."""
        # Utiliser le m√™me Python que celui qui ex√©cute ce script
        return sys.executable
    
    def _validate_paths(self) -> bool:
        """Valide que les fichiers requis existent."""
        mcp_main_path = Path("services/mcp/main.py")
        streamlit_app_path = Path("streamlit_app.py")
        
        if not mcp_main_path.exists():
            print(f"‚ùå Fichier MCP non trouv√©: {mcp_main_path}")
            return False
        
        if not streamlit_app_path.exists():
            print(f"‚ùå Fichier Streamlit non trouv√©: {streamlit_app_path}")
            return False
        
        return True
    
    def start_mcp_server(self) -> bool:
        """
        Lance le serveur MCP en arri√®re-plan.
        
        Returns:
            True si le processus a √©t√© lanc√© avec succ√®s, False sinon
        """
        print("üöÄ Lancement du serveur MCP...")
        
        try:
            # D√©finir les variables d'environnement pour le serveur MCP
            env = os.environ.copy()
            env["HOST"] = self.host
            env["PORT"] = str(self.mcp_port)
            
            # Lancer le serveur MCP
            self.mcp_process = subprocess.Popen(
                [self._get_python_executable(), "services/mcp/main.py"],
                cwd=os.getcwd(),
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',  # Forcer l'encodage UTF-8
                errors='replace',  # Remplacer les caract√®res non d√©codables
                bufsize=1,  # Line buffered
                universal_newlines=True
            )
            
            print(f"   ‚úÖ Processus MCP lanc√© (PID: {self.mcp_process.pid})")
            print(f"   üåê URL du serveur: {self.mcp_url}")
            return True
            
        except Exception as e:
            print(f"   ‚ùå Erreur lors du lancement du serveur MCP: {e}")
            return False
    
    def wait_for_mcp_health(self) -> bool:
        """
        Attend que le serveur MCP soit op√©rationnel via health check.
        
        Returns:
            True si le serveur r√©pond correctement, False si timeout
        """
        print("üîç V√©rification de l'√©tat du serveur MCP...")
        
        start_time = time.time()
        attempt = 0
        
        while time.time() - start_time < self.health_check_timeout:
            attempt += 1
            
            try:
                # Essayer de se connecter au serveur MCP
                with httpx.Client(timeout=5.0) as client:
                    # Essayer le endpoint /invoke qui est le point d'entr√©e principal du serveur MCP
                    # selon l'architecture FastMCP streamable-http
                    try:
                        # Envoyer une requ√™te de "ping" via le protocole MCP
                        payload = {
                            "method": "tools/list",
                            "params": {}
                        }
                        response = client.post(
                            f"{self.mcp_url}/invoke",
                            json=payload,
                            headers={"Content-Type": "application/json"}
                        )
                        
                        if response.status_code == 200:
                            # V√©rifier que la r√©ponse est au format MCP attendu
                            try:
                                result = response.json()
                                if "result" in result:
                                    print(f"   ‚úÖ Serveur MCP op√©rationnel (tentative {attempt})")
                                    return True
                            except ValueError:
                                # R√©ponse non-JSON, mais le serveur r√©pond
                                pass
                    except httpx.HTTPStatusError:
                        pass
                    
                    # Alternative: tester la connectivit√© de base sur l'endpoint racine
                    try:
                        response = client.get(f"{self.mcp_url}/")
                        if response.status_code in [200, 404, 405]:  # Le serveur r√©pond
                            print(f"   ‚úÖ Serveur MCP accessible (tentative {attempt})")
                            return True
                    except httpx.HTTPStatusError:
                        pass
                        
            except httpx.RequestError as e:
                # Serveur pas encore pr√™t
                if attempt % 5 == 0:  # Afficher les erreurs seulement toutes les 5 tentatives
                    print(f"   ‚è≥ Tentative {attempt}: {e}")
            
            except Exception as e:
                print(f"   ‚ö†Ô∏è  Erreur inattendue (tentative {attempt}): {e}")
            
            # V√©rifier si le processus MCP est toujours vivant
            if self.mcp_process and self.mcp_process.poll() is not None:
                print("   ‚ùå Le processus MCP s'est arr√™t√© de mani√®re inattendue")
                return_code = self.mcp_process.returncode
                print(f"   üìä Code de sortie: {return_code}")
                
                # Lire les logs d'erreur et de sortie
                try:
                    if self.mcp_process.stderr:
                        stderr_output = self.mcp_process.stderr.read()
                        if stderr_output.strip():
                            print(f"   üìù Erreurs MCP:")
                            for line in stderr_output.strip().split('\n'):
                                print(f"     {line}")
                    
                    if self.mcp_process.stdout:
                        stdout_output = self.mcp_process.stdout.read()
                        if stdout_output.strip():
                            print(f"   üìÑ Sortie MCP:")
                            for line in stdout_output.strip().split('\n'):
                                print(f"     {line}")
                except Exception as e:
                    print(f"   ‚ö†Ô∏è  Impossible de lire les logs: {e}")
                return False
            
            time.sleep(self.health_check_interval)
        
        print(f"   ‚ùå Timeout apr√®s {self.health_check_timeout} secondes")
        return False
    
    def start_streamlit(self) -> bool:
        """
        Lance l'application Streamlit.
        
        Returns:
            True si le processus a √©t√© lanc√© avec succ√®s, False sinon
        """
        print("üé® Lancement de l'application Streamlit...")
        
        try:
            # D√©finir les variables d'environnement pour Streamlit
            env = os.environ.copy()
            
            # S'assurer que l'URL du serveur MCP est configur√©e
            env["MCP_SERVER_URL"] = self.mcp_url
            
            # Lancer Streamlit
            streamlit_cmd = [
                self._get_python_executable(),
                "-m", "streamlit", "run",
                "streamlit_app.py",
                "--server.address", self.host,
                "--server.port", str(self.streamlit_port),
                "--server.headless", "true",
                "--browser.gatherUsageStats", "false"
            ]
            
            self.streamlit_process = subprocess.Popen(
                streamlit_cmd,
                cwd=os.getcwd(),
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',  # Forcer l'encodage UTF-8
                errors='replace'   # Remplacer les caract√®res non d√©codables
            )
            
            print(f"   ‚úÖ Processus Streamlit lanc√© (PID: {self.streamlit_process.pid})")
            print(f"   üåê URL de l'application: {self.streamlit_url}")
            return True
            
        except Exception as e:
            print(f"   ‚ùå Erreur lors du lancement de Streamlit: {e}")
            return False
    
    def run(self) -> int:
        """
        Lance l'ensemble de l'application RegulAI.
        
        Returns:
            Code de sortie (0 = succ√®s, 1 = erreur)
        """
        print("‚öñÔ∏è  === D√©marrage de RegulAI ===")
        print(f"üè† R√©pertoire de travail: {os.getcwd()}")
        print(f"üêç Python: {self._get_python_executable()}")
        print()
        
        # Validation des fichiers
        if not self._validate_paths():
            return 1
        
        try:
            # √âtape 1: Lancer le serveur MCP
            if not self.start_mcp_server():
                return 1
            
            # √âtape 2: Attendre que le serveur MCP soit pr√™t
            if not self.wait_for_mcp_health():
                print("‚ùå Le serveur MCP n'a pas pu d√©marrer correctement")
                print()
                print("üí° Conseils de d√©pannage :")
                print("   ‚Ä¢ V√©rifiez que les variables d'environnement OAuth sont configur√©es")
                print("   ‚Ä¢ Copiez .env.example vers .env et remplissez les valeurs")
                print("   ‚Ä¢ V√©rifiez la documentation : cat USAGE_START.md")
                print("   ‚Ä¢ Consultez les logs ci-dessus pour plus de d√©tails")
                return 1
            
            # √âtape 3: Lancer Streamlit
            if not self.start_streamlit():
                return 1
            
            # Succ√®s !
            print()
            print("üéâ === RegulAI lanc√© avec succ√®s ! ===")
            print(f"üîó Serveur MCP:        {self.mcp_url}")
            print(f"üåê Application web:    {self.streamlit_url}")
            print()
            print("üí° Appuyez sur Ctrl+C pour arr√™ter tous les services")
            print("üìñ Pour acc√©der √† l'application, ouvrez votre navigateur sur:")
            print(f"   {self.streamlit_url}")
            print()
            
            # Attendre que les processus se terminent ou soient interrompus
            try:
                while True:
                    # V√©rifier que les processus sont toujours vivants
                    if self.mcp_process and self.mcp_process.poll() is not None:
                        print("‚ö†Ô∏è  Le serveur MCP s'est arr√™t√©")
                        break
                    
                    if self.streamlit_process and self.streamlit_process.poll() is not None:
                        print("‚ö†Ô∏è  L'application Streamlit s'est arr√™t√©e")
                        break
                    
                    time.sleep(1)
                    
            except KeyboardInterrupt:
                print("\nüõë Arr√™t demand√© par l'utilisateur")
            
            return 0
            
        except Exception as e:
            print(f"‚ùå Erreur critique: {e}")
            return 1
        finally:
            self.cleanup()


def main():
    """Point d'entr√©e principal."""
    parser = argparse.ArgumentParser(
        description="Lance RegulAI (serveur MCP + interface Streamlit)",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        epilog="""
Exemples d'usage:
  python start.py                                   # Lancement par d√©faut
  python start.py --port 8080 --mcp-port 9000       # Ports personnalis√©s
  python start.py --host 0.0.0.0                    # Accessible depuis l'ext√©rieur
  python start.py --timeout 60                      # Timeout plus long
        """
    )
    
    parser.add_argument(
        "--host",
        default="127.0.0.1",
        help="Adresse d'√©coute pour les serveurs"
    )
    parser.add_argument(
        "--port",
        type=int,
        default=8501,
        help="Port pour l'application Streamlit"
    )
    parser.add_argument(
        "--mcp-port",
        type=int,
        default=8000,
        help="Port pour le serveur MCP"
    )
    parser.add_argument(
        "--timeout",
        type=int,
        default=30,
        help="Timeout pour le health check du serveur MCP (secondes)"
    )
    parser.add_argument(
        "--check-interval",
        type=float,
        default=1.0,
        help="Intervalle entre les v√©rifications de health check (secondes)"
    )
    
    args = parser.parse_args()
    
    # Cr√©er et lancer le lanceur
    launcher = RegulAILauncher(
        host=args.host,
        streamlit_port=args.port,
        mcp_port=args.mcp_port,
        health_check_timeout=args.timeout,
        health_check_interval=args.check_interval
    )
    
    exit_code = launcher.run()
    sys.exit(exit_code)


if __name__ == "__main__":
    main() 