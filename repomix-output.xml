This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: openapi.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
.gitignore
examples/__init__.py
examples/simple_conversation.py
langgraph.json
PROJET_STRUCTURE.md
pyproject.toml
scripts/__init__.py
scripts/validate_tools.py
services/__init__.py
services/mcp/__init__.py
services/mcp/main.py
services/mcp/utils.py
src/regulai/__init__.py
src/regulai/agent.py
src/regulai/config.py
src/regulai/graph.py
src/regulai/tools.py
tests/__init__.py
tests/conftest.py
tests/test_tools.py
tools_validation_report.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# Configuration RegulAI
OPENAI_API_KEY=your_key_here
MCP_SERVER_URL=http://localhost:8000
MCP_TIMEOUT=30
MODEL_NAME=gpt-4o-mini
MODEL_TEMPERATURE=0.0
MAX_ITERATIONS=20
DEFAULT_MAX_RESULTS=10
LOG_LEVEL=INFO
</file>

<file path=".gitignore">
.env
.venv
repomix.config.json
repomix-output.xml
.repomixignore
.pytest_cache
</file>

<file path="examples/__init__.py">
# Exemples d'utilisation du package RegulAI
</file>

<file path="examples/simple_conversation.py">
#!/usr/bin/env python3
"""
Exemple simple d'utilisation de l'agent RegulAI.

Ce script d√©montre comment utiliser l'agent RegulAI pour une conversation
basique sur le droit fran√ßais.
"""

import os
import sys

# Ajouter le r√©pertoire src au PYTHONPATH pour les imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "src"))

from regulai.agent import create_agent, run_agent_conversation, stream_agent_conversation
from regulai.config import get_config


def exemple_conversation_simple():
    """Exemple de conversation simple avec l'agent."""
    print("ü§ñ RegulAI - Exemple de Conversation Simple")
    print("=" * 60)
    
    try:
        # V√©rifier la configuration
        config = get_config()
        print(f"üìã Configuration:")
        print(f"   - Mod√®le: {config.model_name}")
        print(f"   - Serveur MCP: {config.mcp_server_url}")
        print(f"   - API Key configur√©e: {'‚úÖ' if config.openai_api_key else '‚ùå'}")
        
        if not config.openai_api_key:
            print("\n‚ùå OPENAI_API_KEY n'est pas configur√©")
            print("Veuillez copier .env.example vers .env et remplir votre cl√© API")
            return
        
        # Cr√©er l'agent
        print(f"\nüèóÔ∏è  Cr√©ation de l'agent...")
        agent = create_agent()
        print("‚úÖ Agent cr√©√© avec succ√®s")
        
        # Messages d'exemple
        messages_test = [
            "Bonjour ! Peux-tu m'expliquer ce qu'est le droit du travail en France ?",
            "Comment fonctionne la recherche dans L√©gifrance ?",
            "Peux-tu rechercher des informations sur les cong√©s pay√©s ?",
        ]
        
        for i, message in enumerate(messages_test, 1):
            print(f"\n" + "‚îÄ" * 60)
            print(f"üí¨ Exemple {i}: {message}")
            print("‚îÄ" * 60)
            
            # Utiliser l'agent pour r√©pondre
            response = run_agent_conversation(
                message, 
                thread_id=f"exemple-{i}",
                agent=agent
            )
            
            print(f"ü§ñ R√©ponse: {response}")
        
        print(f"\n" + "=" * 60)
        print("‚úÖ Tous les exemples ont √©t√© ex√©cut√©s avec succ√®s !")
        
    except Exception as e:
        print(f"\n‚ùå Erreur: {e}")
        print("\nV√©rifiez votre configuration et r√©essayez.")


def exemple_conversation_streaming():
    """Exemple de conversation avec streaming en temps r√©el."""
    print("\nüåä RegulAI - Exemple avec Streaming")
    print("=" * 60)
    
    try:
        # Cr√©er l'agent
        agent = create_agent()
        
        # Message de test pour le streaming
        message = "Peux-tu me donner un aper√ßu complet du Code du travail fran√ßais ?"
        print(f"üí¨ Question: {message}")
        print("ü§ñ R√©ponse en streaming:")
        print("‚îÄ" * 40)
        
        # Utiliser le streaming
        for step in stream_agent_conversation(message, "streaming-example", agent):
            if "messages" in step:
                last_message = step["messages"][-1]
                if hasattr(last_message, 'content') and last_message.content:
                    # Afficher le contenu s'il ne s'agit pas d'appels d'outils
                    if not hasattr(last_message, 'tool_calls') or not last_message.tool_calls:
                        print(f"üìù {last_message.content}")
                    else:
                        print(f"üîß [Appel d'outils en cours...]")
        
        print("‚îÄ" * 40)
        print("‚úÖ Streaming termin√©")
        
    except Exception as e:
        print(f"‚ùå Erreur lors du streaming: {e}")


def main():
    """Fonction principale."""
    print("üöÄ Exemples d'utilisation de RegulAI")
    print("=" * 60)
    
    # V√©rifier les d√©pendances
    try:
        import regulai
        print("‚úÖ Package RegulAI import√© avec succ√®s")
    except ImportError as e:
        print(f"‚ùå Erreur d'import: {e}")
        print("Assurez-vous d'avoir install√© le package avec: pip install -e .")
        return
    
    # Ex√©cuter les exemples
    try:
        exemple_conversation_simple()
        print("\n" + "="*20)
        exemple_conversation_streaming()
        
    except KeyboardInterrupt:
        print("\n\nüëã Arr√™t demand√© par l'utilisateur")
    except Exception as e:
        print(f"\n‚ùå Erreur g√©n√©rale: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
</file>

<file path="langgraph.json">
{
    "dependencies": ["./src/regulai"],
    "graphs": {
        "regulai_agent": "./src/regulai/agent.py:create_agent"
    },
    "env": ".env"
}
</file>

<file path="PROJET_STRUCTURE.md">
# Structure du Projet RegulAI

## üéØ Objectif

Construire un agent IA avec LangGraph qui interagit avec le serveur MCP L√©gifrance existant. L'architecture suit le pattern client-serveur o√π le serveur MCP s'ex√©cute comme un service ind√©pendant et l'agent LangGraph agit comme un client HTTP.

## üìÅ Structure des Fichiers

```
RegulAI/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ mcp/                    # Serveur MCP existant
‚îÇ   ‚îî‚îÄ‚îÄ agent/                  # üÜï Nouvel agent LangGraph
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py         # Package Python
‚îÇ       ‚îú‚îÄ‚îÄ main.py             # Agent principal (ReAct)
‚îÇ       ‚îú‚îÄ‚îÄ tools.py            # Interface HTTP vers MCP
‚îÇ       ‚îú‚îÄ‚îÄ test_agent.py       # Tests avec outils simul√©s
‚îÇ       ‚îî‚îÄ‚îÄ README.md           # Documentation agent
‚îú‚îÄ‚îÄ pyproject.toml              # ‚úÖ D√©pendances mises √† jour
‚îú‚îÄ‚îÄ README.md                   # Documentation projet
‚îî‚îÄ‚îÄ PROJET_STRUCTURE.md         # Ce fichier
```

## üèóÔ∏è Architecture

L'agent utilise l'**API fonctionnelle de LangGraph** avec les d√©corateurs :
- `@task` : T√¢ches individuelles (call_model, call_tool)
- `@entrypoint` : Workflow principal avec persistance
- **Pattern ReAct** : Reasoning ‚Üí Action ‚Üí Observation

## üì¶ D√©pendances Ajout√©es

```toml
dependencies = [
    "fastmcp @ git+https://github.com/jlowin/fastmcp.git",  # Existant
    "langgraph>=0.2.16",           # üÜï Framework principal
    "langchain-openai>=0.2.0",     # üÜï Provider LLM
    "langchain-core>=0.3.0",       # üÜï Messages et outils
    "httpx>=0.27.0",               # üÜï Client HTTP
    "pydantic>=2.0.0"              # üÜï Validation donn√©es
]
```

## üîß Composants Principaux

### 1. Agent Principal (`main.py`)
- **Architecture ReAct** avec boucle raisonnement/action
- **Persistance** des conversations via MemorySaver
- **Streaming** des r√©ponses en temps r√©el
- **Gestion d'erreurs** robuste

### 2. Interface MCP (`tools.py`)
- **Client HTTP** vers le serveur MCP (localhost:8000)
- **Conversion** outils MCP ‚Üí format LangChain
- **Outils disponibles** :
  - `search_legifrance` : Recherche textes juridiques
  - `get_article` : R√©cup√©ration article par ID
  - `browse_code` : Navigation codes juridiques

### 3. Tests Simul√©s (`test_agent.py`)
- **Tests ind√©pendants** sans serveur MCP
- **Outils mock√©s** avec donn√©es r√©alistes
- **Validation** du pattern ReAct

## üöÄ Utilisation

### Installation
```bash
pip install langgraph langchain-openai langchain-core httpx pydantic
```

### Test rapide
```bash
python src/agent/test_agent.py
```

### Utilisation avec serveur MCP
```python
from src.agent.main import agent
from langchain_core.messages import HumanMessage

# Configuration
config = {"configurable": {"thread_id": "session-123"}}
message = HumanMessage(content="Quelles sont les r√®gles sur les cong√©s pay√©s?")

# Ex√©cution
for step in agent.stream([message], config=config):
    for task_name, result in step.items():
        if task_name != "agent":
            print(f"{task_name}: {result}")
```

## üìã Prochaines √âtapes

### Phase 1 : Tests et Validation ‚úÖ
- [x] Structure du projet cr√©√©e
- [x] Agent LangGraph impl√©ment√©
- [x] Interface HTTP vers MCP
- [x] Tests simul√©s fonctionnels
- [x] Outils avec d√©corateur @tool
- [x] Sch√©mas Pydantic pour validation
- [x] Scripts de validation et exemples

### Phase 2 : Int√©gration MCP
- [ ] D√©marrer le serveur MCP L√©gifrance
- [ ] Tester l'int√©gration compl√®te
- [ ] R√©cup√©ration dynamique des outils MCP
- [ ] Am√©liorer le parsing des r√©ponses

### Phase 3 : Fonctionnalit√©s Avanc√©es
- [ ] Interface web (Streamlit/FastAPI)
- [ ] Cache des requ√™tes fr√©quentes
- [ ] M√©triques et observabilit√©
- [ ] Tests automatis√©s complets

### Phase 4 : Production
- [ ] D√©ploiement containeris√©
- [ ] Configuration via variables d'environnement
- [ ] Monitoring et alertes
- [ ] Documentation utilisateur

## üîç Points d'Attention

1. **Variables d'environnement** : OPENAI_API_KEY requis
2. **Serveur MCP** : Doit √™tre d√©marr√© sur localhost:8000
3. **Format des r√©ponses** : Adapter le parsing selon l'API MCP
4. **Gestion d'erreurs** : Timeout HTTP, erreurs r√©seau
5. **Rate limiting** : Limites API OpenAI et L√©gifrance

## üìö Documentation de R√©f√©rence

- **LangGraph Functional API** : how-tos/react-agent-from-scratch-functional.ipynb
- **Pattern ReAct** : Reasoning and Acting avec outils
- **MCP Protocol** : Model Context Protocol pour l'interop√©rabilit√©
- **L√©gifrance API** : Base de donn√©es juridique fran√ßaise

L'architecture est maintenant pr√™te pour les tests d'int√©gration avec le serveur MCP r√©el ! üéâ
</file>

<file path="pyproject.toml">
[project]
name = "regulai"
version = "0.2.0"
description = "Agent IA ReAct avec int√©gration MCP pour recherche juridique"
authors = [
    {name = "RegulAI Team", email = "team@regulai.com"}
]
license = {text = "MIT"}
readme = "README.md"
requires-python = ">=3.12,<4.0"
dependencies = [
    # "fastmcp @ git+https://github.com/jlowin/fastmcp.git",  # Temporairement comment√©
    "langgraph>=0.2.16",
    "langchain-openai>=0.2.0",
    "langchain-core>=0.3.0",
    "httpx>=0.27.0",
    "pydantic>=2.0.0",
    "pydantic-settings>=2.0.0"
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",
    "pytest-mock>=3.10.0",
    "black>=23.0.0",
    "isort>=5.12.0",
    "mypy>=1.0.0"
]

[project.scripts]
regulai = "regulai.agent:main"
regulai-validate = "scripts.validate_tools:main"

[tool.setuptools]
package-dir = {"" = "src"}

[tool.setuptools.packages.find]
where = ["src"]

[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
asyncio_mode = "auto"

[tool.black]
line-length = 88
target-version = ['py312']

[tool.isort]
profile = "black"
src_paths = ["src", "scripts", "examples", "tests"]

[tool.mypy]
python_version = "3.12"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
</file>

<file path="scripts/__init__.py">
# Scripts d'administration et de maintenance pour RegulAI
</file>

<file path="scripts/validate_tools.py">
"""
Script de validation des outils LangGraph L√©gifrance.

Ce script v√©rifie que tous les outils sont correctement configur√©s
et peuvent √™tre utilis√©s par l'agent LangGraph.
"""

import json
import os
import sys
from typing import Dict, Any

# Ajouter le r√©pertoire src au PYTHONPATH pour les imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "src"))

from regulai.tools import get_available_tools, test_mcp_connection, get_mcp_server_info
from regulai.config import get_config


def validate_tool_structure(tool) -> Dict[str, Any]:
    """
    Valide la structure d'un outil LangChain.
    
    Args:
        tool: Outil √† valider
        
    Returns:
        Dictionnaire avec les r√©sultats de validation
    """
    validation = {
        "name": tool.name,
        "has_description": bool(tool.description),
        "has_args_schema": hasattr(tool, 'args_schema') and tool.args_schema is not None,
        "schema_fields": [],
        "errors": []
    }
    
    # V√©rifier le sch√©ma d'arguments
    if validation["has_args_schema"]:
        try:
            schema = tool.args_schema.schema()
            validation["schema_fields"] = list(schema.get("properties", {}).keys())
            validation["schema_valid"] = True
        except Exception as e:
            validation["errors"].append(f"Erreur sch√©ma: {e}")
            validation["schema_valid"] = False
    else:
        validation["errors"].append("Pas de sch√©ma d'arguments d√©fini")
        validation["schema_valid"] = False
    
    # V√©rifier que l'outil est invocable
    try:
        # Test avec des arguments vides pour v√©rifier la structure
        tool.get_input_schema()
        validation["invocable"] = True
    except Exception as e:
        validation["errors"].append(f"Outil non invocable: {e}")
        validation["invocable"] = False
    
    return validation


def test_tool_invocation(tool, test_args: Dict[str, Any]) -> Dict[str, Any]:
    """
    Teste l'invocation d'un outil avec des arguments de test.
    
    Args:
        tool: Outil √† tester
        test_args: Arguments de test
        
    Returns:
        R√©sultats du test
    """
    test_result = {
        "tool_name": tool.name,
        "test_args": test_args,
        "success": False,
        "response": None,
        "error": None,
        "response_length": 0
    }
    
    try:
        response = tool.invoke(test_args)
        test_result["success"] = True
        test_result["response"] = response
        test_result["response_length"] = len(str(response))
        
        # V√©rifier que la r√©ponse n'est pas une erreur
        response_str = str(response).lower()
        if any(error_keyword in response_str for error_keyword in ["erreur", "error", "connexion", "timeout"]):
            test_result["warning"] = "La r√©ponse semble contenir une erreur"
            
    except Exception as e:
        test_result["error"] = str(e)
    
    return test_result


def validate_all_tools():
    """Valide tous les outils disponibles."""
    print("üîç Validation des outils LangGraph L√©gifrance")
    print("=" * 60)
    
    # 1. Tester la connexion MCP
    print("\nüì° Test de connexion MCP")
    print("-" * 30)
    
    mcp_available = test_mcp_connection()
    if mcp_available:
        print("‚úÖ Serveur MCP accessible")
        server_info = get_mcp_server_info()
        if server_info:
            print(f"üìä Info serveur: {json.dumps(server_info, indent=2)}")
    else:
        print("‚ö†Ô∏è  Serveur MCP non accessible - les tests d'invocation pourraient √©chouer")
    
    # 2. R√©cup√©rer et valider les outils
    print("\nüîß Validation de la structure des outils")
    print("-" * 40)
    
    tools = get_available_tools()
    print(f"Nombre d'outils trouv√©s: {len(tools)}")
    
    validation_results = []
    for tool in tools:
        validation = validate_tool_structure(tool)
        validation_results.append(validation)
        
        # Afficher les r√©sultats
        print(f"\nüìù Outil: {validation['name']}")
        print(f"   Description: {'‚úÖ' if validation['has_description'] else '‚ùå'}")
        print(f"   Sch√©ma args: {'‚úÖ' if validation['has_args_schema'] else '‚ùå'}")
        print(f"   Invocable: {'‚úÖ' if validation['invocable'] else '‚ùå'}")
        print(f"   Champs: {validation['schema_fields']}")
        
        if validation['errors']:
            print(f"   ‚ö†Ô∏è  Erreurs: {validation['errors']}")
    
    # 3. Tests d'invocation
    print("\nüöÄ Tests d'invocation des outils")
    print("-" * 35)
    
    # Arguments de test pour chaque outil
    test_cases = {
        "search_legifrance": {"query": "test validation", "max_results": 1},
        "get_article": {"article_id": "L3141-1"},
        "browse_code": {"code_name": "Code du travail", "section": "L3141"}
    }
    
    invocation_results = []
    for tool in tools:
        if tool.name in test_cases:
            test_args = test_cases[tool.name]
            result = test_tool_invocation(tool, test_args)
            invocation_results.append(result)
            
            # Afficher les r√©sultats
            print(f"\nüß™ Test {tool.name}")
            print(f"   Arguments: {test_args}")
            print(f"   Succ√®s: {'‚úÖ' if result['success'] else '‚ùå'}")
            print(f"   Longueur r√©ponse: {result['response_length']} chars")
            
            if result['error']:
                print(f"   ‚ùå Erreur: {result['error']}")
            elif result.get('warning'):
                print(f"   ‚ö†Ô∏è  {result['warning']}")
            elif result['success']:
                # Afficher un aper√ßu de la r√©ponse
                response_preview = str(result['response'])[:100]
                print(f"   üìÑ Aper√ßu: {response_preview}...")
    
    # 4. R√©sum√© des r√©sultats
    print("\nüìä R√©sum√© de la validation")
    print("=" * 30)
    
    total_tools = len(tools)
    valid_structure = sum(1 for v in validation_results if v['invocable'] and v['has_args_schema'])
    successful_invocations = sum(1 for r in invocation_results if r['success'])
    
    print(f"Outils totaux: {total_tools}")
    print(f"Structure valide: {valid_structure}/{total_tools}")
    print(f"Invocations r√©ussies: {successful_invocations}/{len(test_cases)}")
    
    # Statut global
    if valid_structure == total_tools and (not mcp_available or successful_invocations > 0):
        print("\n‚úÖ Validation globale: SUCC√àS")
        return True
    else:
        print("\n‚ùå Validation globale: √âCHEC")
        if valid_structure != total_tools:
            print("   - Probl√®mes de structure des outils")
        if mcp_available and successful_invocations == 0:
            print("   - Aucune invocation r√©ussie malgr√© serveur MCP disponible")
        return False


def generate_tools_report():
    """G√©n√®re un rapport d√©taill√© des outils."""
    print("\nüìã G√©n√©ration du rapport des outils")
    print("-" * 40)
    
    tools = get_available_tools()
    
    report = {
        "timestamp": str(type(None).__module__ == "builtins" and True),  # Simple timestamp
        "mcp_server_available": test_mcp_connection(),
        "tools_count": len(tools),
        "tools": []
    }
    
    for tool in tools:
        tool_info = {
            "name": tool.name,
            "description": tool.description,
            "schema": None
        }
        
        # Extraire le sch√©ma
        try:
            if hasattr(tool, 'args_schema') and tool.args_schema:
                schema = tool.args_schema.schema()
                tool_info["schema"] = {
                    "properties": schema.get("properties", {}),
                    "required": schema.get("required", [])
                }
        except Exception as e:
            tool_info["schema_error"] = str(e)
        
        report["tools"].append(tool_info)
    
    # Sauvegarder le rapport
    try:
        with open("tools_validation_report.json", "w", encoding="utf-8") as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        print("‚úÖ Rapport sauvegard√©: tools_validation_report.json")
    except Exception as e:
        print(f"‚ùå Erreur sauvegarde rapport: {e}")
    
    return report


def main():
    """Fonction principale de validation."""
    try:
        # Validation compl√®te
        success = validate_all_tools()
        
        # G√©n√©ration du rapport
        generate_tools_report()
        
        # Statut final
        if success:
            print("\nüéâ Validation termin√©e avec succ√®s!")
            print("Les outils sont pr√™ts pour l'utilisation avec l'agent LangGraph.")
        else:
            print("\n‚ö†Ô∏è  Validation termin√©e avec des probl√®mes.")
            print("V√©rifiez les erreurs ci-dessus avant d'utiliser l'agent.")
        
        return success
        
    except Exception as e:
        print(f"\n‚ùå Erreur durant la validation: {e}")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    main()
</file>

<file path="services/__init__.py">
# Services externes autonomes
</file>

<file path="services/mcp/__init__.py">
# Service MCP autonome
</file>

<file path="services/mcp/main.py">
# src/main.py
import os
import signal
import sys
from dotenv import load_dotenv
from utils import create_mcp_from_openapi

# Charger les variables d'environnement depuis un fichier .env
load_dotenv()

print("Cr√©ation du serveur MCP √† partir de la sp√©cification OpenAPI...")

# Cr√©er l'instance du serveur en utilisant notre fonction utilitaire
mcp = create_mcp_from_openapi()

print(f"Serveur MCP '{mcp.name}' cr√©√© avec succ√®s. D√©marrage...")

def signal_handler(signum, frame):
    """
    Gestionnaire de signal pour un arr√™t propre du serveur
    """
    print("\nüõë Arr√™t du serveur demand√©...")
    print("üëã Serveur arr√™t√© proprement!")
    sys.exit(0)

# Le bloc d'ex√©cution principal
if __name__ == "__main__":
    # Configurer le gestionnaire de signal pour Ctrl+C (SIGINT)
    signal.signal(signal.SIGINT, signal_handler)
    
    # R√©cup√©rer l'h√¥te et le port depuis les variables d'environnement, avec des valeurs par d√©faut
    host = os.getenv("HOST", "127.0.0.1")
    port = int(os.getenv("PORT", "8000"))

    try:
        print(f"üöÄ Serveur d√©marr√© sur http://{host}:{port}")
        print("üí° Appuyez sur Ctrl+C pour arr√™ter le serveur")
        
        # Lancer le serveur avec le transport HTTP recommand√© pour ce cas d'usage
        # Voir : https://gofastmcp.com/deployment/running-server#streamable-http
        mcp.run(transport="streamable-http", host=host, port=port)
    except KeyboardInterrupt:
        # Au cas o√π le signal handler ne capture pas l'interruption
        print("\nüõë Arr√™t du serveur demand√©...")
        print("üëã Serveur arr√™t√© proprement!")
        sys.exit(0)
    except Exception as e:
        print(f"‚ùå Erreur lors du d√©marrage du serveur : {e}")
        sys.exit(1)
</file>

<file path="services/mcp/utils.py">
# src/utils.py
import os
import json
import httpx
from pathlib import Path
from fastmcp import FastMCP

def get_access_token() -> str:
    """
    R√©cup√®re un jeton d'acc√®s (access token) aupr√®s du serveur OAuth de PISTE
    en utilisant les identifiants client (Client Credentials).
    """
    client_id = os.getenv("OAUTH_CLIENT_ID")
    client_secret = os.getenv("OAUTH_CLIENT_SECRET")
    token_url = os.getenv("OAUTH_TOKEN_URL")

    if not all([client_id, client_secret, token_url]):
        raise ValueError("Les variables d'environnement OAUTH_CLIENT_ID, OAUTH_CLIENT_SECRET, et OAUTH_TOKEN_URL sont requises.")

    # Assurance pour le type checker que token_url n'est pas None apr√®s la v√©rification
    assert token_url is not None

    print("Demande d'un jeton d'acc√®s (access token) √† PISTE...")
    
    # Le corps de la requ√™te pour obtenir le token
    data = {
        "grant_type": "client_credentials",
        "client_id": client_id,
        "client_secret": client_secret,
    }

    try:
        # On utilise un client synchrone ici car c'est une action unique au d√©marrage
        response = httpx.post(token_url, data=data)
        response.raise_for_status()  # L√®ve une exception si la requ√™te √©choue (ex: 401, 500)
        
        token_data = response.json()
        access_token = token_data.get("access_token")

        if not access_token:
            raise ValueError("La r√©ponse du serveur OAuth ne contient pas d'access_token.")
            
        print("Jeton d'acc√®s obtenu avec succ√®s !")
        return access_token

    except httpx.HTTPStatusError as e:
        print(f"Erreur HTTP lors de l'obtention du token : {e.response.status_code}")
        print(f"R√©ponse du serveur : {e.response.text}")
        raise
    except Exception as e:
        print(f"Une erreur inattendue est survenue lors de l'obtention du token : {e}")
        raise


def create_mcp_from_openapi() -> FastMCP:
    """
    Cr√©e une instance de serveur FastMCP √† partir de la sp√©cification OpenAPI de L√©gifrance.
    """
    # 1. R√©cup√©rer l'URL de base de l'API
    api_base_url = os.getenv("API_BASE_URL")
    if not api_base_url:
        raise ValueError("La variable d'environnement API_BASE_URL n'est pas d√©finie.")

    # 2. Obtenir le jeton d'acc√®s via OAuth 2.0
    access_token = get_access_token()

    # 3. Charger le fichier de sp√©cification OpenAPI
    project_root = Path(__file__).parent.parent.parent
    spec_path = project_root / "openapi.json"
    if not spec_path.exists():
        raise FileNotFoundError(f"Fichier openapi.json non trouv√© √† l'emplacement : {spec_path}")

    with open(spec_path, "r", encoding="utf-8") as f:
        openapi_spec = json.load(f)

    # 4. Configurer le client HTTP avec le jeton d'acc√®s obtenu
    headers = {
        "Authorization": f"Bearer {access_token}",
        # L'API PISTE requiert aussi ce header pour les appels
        "accept": "application/json",
    }
    
    http_client = httpx.AsyncClient(base_url=api_base_url, headers=headers)

    # 5. G√©n√©rer le serveur MCP
    server_name = openapi_spec.get("info", {}).get("title", "L√©gifrance MCP Server")
    
    mcp_server = FastMCP.from_openapi(
        openapi_spec=openapi_spec,
        client=http_client,
        name=server_name,
        timeout=30.0
    )

    return mcp_server
</file>

<file path="src/regulai/__init__.py">
"""
RegulAI - Agent IA ReAct avec int√©gration MCP pour recherche juridique.

Ce package contient l'agent LangGraph principal et ses composants.
"""

__version__ = "0.2.0"
__author__ = "RegulAI Team"

from .agent import create_agent
from .config import RegulAIConfig

__all__ = ["create_agent", "RegulAIConfig"]
</file>

<file path="src/regulai/agent.py">
"""
Agent RegulAI principal avec architecture StateGraph.

Ce module assemble les n≈ìuds d√©finis dans graph.py pour cr√©er l'agent LangGraph
complet avec persistance et streaming.
"""

from typing import Optional, Any, Dict
from langchain_core.messages import HumanMessage
from langchain_core.runnables import RunnableConfig
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph.graph import CompiledGraph

from .config import get_config
from .graph import AgentState, call_model, call_tools, should_continue


def create_agent(checkpointer: Optional[MemorySaver] = None) -> CompiledGraph:
    """
    Cr√©e et compile l'agent RegulAI avec architecture StateGraph.
    
    Args:
        checkpointer: Checkpointer pour la persistance (utilise MemorySaver par d√©faut)
        
    Returns:
        Agent LangGraph compil√© et pr√™t √† utiliser
        
    Raises:
        ValueError: Si la configuration est invalide
    """
    # Valider la configuration
    config = get_config()
    
    # Cr√©er le StateGraph avec l'√©tat AgentState
    workflow = StateGraph(AgentState)
    
    # Ajouter les n≈ìuds
    workflow.add_node("agent", call_model)
    workflow.add_node("tools", call_tools)
    
    # D√©finir le point d'entr√©e
    workflow.set_entry_point("agent")
    
    # Ajouter les ar√™tes conditionnelles
    workflow.add_conditional_edges(
        "agent",
        should_continue,
        {
            "tools": "tools",
            "__end__": END,
        },
    )
    
    # Apr√®s les outils, retourner √† l'agent
    workflow.add_edge("tools", "agent")
    
    # Compiler le graphe avec un checkpointer
    if checkpointer is None:
        checkpointer = MemorySaver()
    
    compiled_graph = workflow.compile(checkpointer=checkpointer)
    
    return compiled_graph


def run_agent_conversation(
    message: str, 
    thread_id: str = "default-session",
    agent: Optional[CompiledGraph] = None
) -> str:
    """
    Lance une conversation avec l'agent RegulAI.
    
    Args:
        message: Message de l'utilisateur
        thread_id: ID de session pour la persistance
        agent: Instance de l'agent (cr√©√©e automatiquement si None)
        
    Returns:
        R√©ponse finale de l'agent
        
    Raises:
        ValueError: Si la configuration est invalide
    """
    if agent is None:
        agent = create_agent()
    
    # Cr√©er le message utilisateur
    user_message = HumanMessage(content=message)
    
    # Configuration pour la persistance
    config: RunnableConfig = {"configurable": {"thread_id": thread_id}}
    
    # Invoquer l'agent
    result = agent.invoke(
        {"messages": [user_message]},
        config=config
    )
    
    # R√©cup√©rer la r√©ponse finale
    if result and "messages" in result:
        last_message = result["messages"][-1]
        if hasattr(last_message, 'content'):
            return last_message.content
    
    return "Aucune r√©ponse de l'agent"


def stream_agent_conversation(
    message: str,
    thread_id: str = "default-session", 
    agent: Optional[CompiledGraph] = None
):
    """
    Lance une conversation avec streaming avec l'agent RegulAI.
    
    Args:
        message: Message de l'utilisateur
        thread_id: ID de session pour la persistance
        agent: Instance de l'agent (cr√©√©e automatiquement si None)
        
    Yields:
        √âtapes interm√©diaires et r√©ponse finale de l'agent
        
    Raises:
        ValueError: Si la configuration est invalide
    """
    if agent is None:
        agent = create_agent()
    
    # Cr√©er le message utilisateur
    user_message = HumanMessage(content=message)
    
    # Configuration pour la persistance
    config: RunnableConfig = {"configurable": {"thread_id": thread_id}}
    
    # Streamer les √©tapes
    for step in agent.stream(
        {"messages": [user_message]},
        config=config,
        stream_mode="values"
    ):
        yield step


def main():
    """
    Fonction principale pour tester l'agent RegulAI.
    
    Lance une conversation de test avec l'agent et affiche les r√©sultats.
    """
    try:
        print("ü§ñ Agent RegulAI - Test de d√©marrage")
        print("=" * 50)
        
        # V√©rifier la configuration
        config = get_config()
        if not config.openai_api_key:
            print("‚ùå Erreur: OPENAI_API_KEY non configur√©")
            print("Copiez .env.example vers .env et remplissez votre cl√© API OpenAI")
            return
        
        print(f"‚úÖ Configuration valid√©e")
        print(f"   - Mod√®le: {config.model_name}")
        print(f"   - Serveur MCP: {config.mcp_server_url}")
        print(f"   - Temperature: {config.model_temperature}")
        
        # Cr√©er l'agent
        print("\nüìù Cr√©ation de l'agent...")
        agent = create_agent()
        print("‚úÖ Agent cr√©√© avec succ√®s")
        
        # Message de test
        test_message = "Bonjour ! Peux-tu m'aider √† rechercher des informations sur les cong√©s pay√©s en France ?"
        print(f"\nüë§ Utilisateur: {test_message}")
        print("\nü§ñ Agent RegulAI:")
        print("-" * 30)
        
        # Lancer la conversation avec streaming
        for step in stream_agent_conversation(test_message, "test-session", agent):
            if "messages" in step:
                last_message = step["messages"][-1]
                if hasattr(last_message, 'content') and last_message.content:
                    # Afficher seulement les nouveaux contenus (pas les appels d'outils)
                    if not hasattr(last_message, 'tool_calls') or not last_message.tool_calls:
                        print(f"üí¨ {last_message.content}")
        
        print("\n" + "=" * 50)
        print("‚úÖ Test termin√© avec succ√®s !")
        
    except Exception as e:
        print(f"\n‚ùå Erreur lors du test: {e}")
        print("\nV√©rifiez votre configuration :")
        print("1. OPENAI_API_KEY est d√©fini dans .env")
        print("2. Le serveur MCP est d√©marr√© (optionnel pour ce test)")


if __name__ == "__main__":
    main()
</file>

<file path="src/regulai/config.py">
"""
Configuration centralis√©e pour RegulAI avec validation Pydantic.

Ce module g√®re toutes les variables d'environnement et param√®tres de configuration
du projet de mani√®re type-safe avec validation automatique.
"""

from typing import Optional
from pydantic import Field
from pydantic_settings import BaseSettings


class RegulAIConfig(BaseSettings):
    """Configuration centralis√©e avec validation Pydantic."""
    
    # ==========================================
    # Configuration Serveur MCP  
    # ==========================================
    mcp_server_url: str = Field(
        default="http://localhost:8000",
        description="URL du serveur MCP L√©gifrance"
    )
    mcp_timeout: int = Field(
        default=30,
        description="Timeout en secondes pour les requ√™tes MCP"
    )
    
    # ==========================================
    # Configuration LLM
    # ==========================================
    openai_api_key: Optional[str] = Field(
        default=None,
        description="Cl√© API OpenAI pour le mod√®le de langage"
    )
    model_name: str = Field(
        default="gpt-4o-mini",
        description="Nom du mod√®le OpenAI √† utiliser"
    )
    model_temperature: float = Field(
        default=0.0,
        ge=0.0,
        le=2.0,
        description="Temp√©rature du mod√®le (0.0 = d√©terministe, 2.0 = tr√®s cr√©atif)"
    )
    
    # ==========================================
    # Configuration Agent
    # ==========================================
    max_iterations: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Nombre maximum d'it√©rations pour l'agent ReAct"
    )
    default_max_results: int = Field(
        default=10,
        ge=1,
        le=50,
        description="Nombre par d√©faut de r√©sultats pour les recherches"
    )
    
    # ==========================================
    # Configuration Logging
    # ==========================================
    log_level: str = Field(
        default="INFO",
        description="Niveau de logging (DEBUG, INFO, WARNING, ERROR, CRITICAL)"
    )
    log_format: str = Field(
        default="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        description="Format des logs"
    )
    
    # ==========================================
    # Configuration Persistance
    # ==========================================
    thread_id: Optional[str] = Field(
        default=None,
        description="ID de thread par d√©faut pour la persistance des conversations"
    )
    
    model_config = {
        "env_file": ".env",
        "env_file_encoding": "utf-8",
        "case_sensitive": False,
        "validate_assignment": True,
        "env_prefix": "",
    }
    
    def validate_openai_key(self) -> str:
        """Valide que la cl√© OpenAI est pr√©sente."""
        if not self.openai_api_key:
            raise ValueError(
                "OPENAI_API_KEY est requis. "
                "D√©finissez la variable d'environnement ou copiez .env.example vers .env"
            )
        return self.openai_api_key


# Fonction pour cr√©er une instance de configuration avec validation
def create_config() -> RegulAIConfig:
    """
    Cr√©e et valide une instance de configuration.
    
    Returns:
        Instance configur√©e et valid√©e de RegulAIConfig
        
    Raises:
        ValueError: Si une configuration requise est manquante
    """
    config = RegulAIConfig()
    # La validation de la cl√© OpenAI sera faite lors de la cr√©ation de l'agent
    return config


# Instance globale de configuration (lazy loading)
_config: Optional[RegulAIConfig] = None


def get_config() -> RegulAIConfig:
    """
    R√©cup√®re l'instance de configuration globale.
    
    Returns:
        Instance configur√©e de RegulAIConfig
    """
    global _config
    if _config is None:
        _config = create_config()
    return _config


def reload_config() -> RegulAIConfig:
    """
    Recharge la configuration depuis les variables d'environnement.
    
    Utile pour les tests ou les changements de configuration √† l'ex√©cution.
    
    Returns:
        Nouvelle instance de RegulAIConfig
    """
    global _config
    _config = create_config()
    return _config
</file>

<file path="src/regulai/graph.py">
"""
D√©finition de l'√©tat et des n≈ìuds du graphe LangGraph pour l'agent RegulAI.

Ce module contient la structure de donn√©es de l'√©tat de l'agent et les fonctions
des n≈ìuds qui composent le workflow ReAct.
"""

from typing import TypedDict, Literal, List, Dict, Any
from langchain_core.messages import BaseMessage, ToolMessage, AIMessage
from langchain_openai import ChatOpenAI

from .config import get_config
from .tools import get_available_tools


# =============================================================================
# √âTAT DU GRAPHE (StateGraph)
# =============================================================================

class AgentState(TypedDict):
    """
    √âtat de l'agent RegulAI pour le StateGraph.
    
    Attributes:
        messages: Liste des messages de la conversation
    """
    messages: List[BaseMessage]


# =============================================================================
# CONFIGURATION ET OUTILS
# =============================================================================

def get_configured_model() -> ChatOpenAI:
    """
    Cr√©e une instance configur√©e du mod√®le OpenAI.
    
    Returns:
        Instance configur√©e de ChatOpenAI
        
    Raises:
        ValueError: Si la cl√© API OpenAI n'est pas configur√©e
    """
    config = get_config()
    
    # Valider la cl√© API
    if not config.openai_api_key:
        raise ValueError(
            "OPENAI_API_KEY est requis. "
            "D√©finissez la variable d'environnement ou copiez .env.example vers .env"
        )
    
    # D√©finir la variable d'environnement si elle n'est pas d√©j√† d√©finie
    import os
    if not os.environ.get("OPENAI_API_KEY"):
        os.environ["OPENAI_API_KEY"] = config.openai_api_key
    
    return ChatOpenAI(
        model=config.model_name,
        temperature=config.model_temperature
    )


def get_tools_dict() -> Dict[str, Any]:
    """
    R√©cup√®re les outils disponibles sous forme de dictionnaire.
    
    Returns:
        Dictionnaire des outils index√©s par nom
    """
    tools = get_available_tools()
    return {tool.name: tool for tool in tools}


# =============================================================================
# N≈íUDS DU GRAPHE
# =============================================================================

def call_model(state: AgentState) -> Dict[str, List[BaseMessage]]:
    """
    N≈ìud qui appelle le mod√®le de langage avec les messages actuels.
    
    Args:
        state: √âtat actuel de l'agent
        
    Returns:
        Dictionnaire avec la nouvelle liste de messages incluant la r√©ponse du mod√®le
    """
    model = get_configured_model()
    tools = get_available_tools()
    
    # Lier les outils au mod√®le et invoquer
    response = model.bind_tools(tools).invoke(state["messages"])
    
    # Retourner l'√©tat mis √† jour avec la r√©ponse du mod√®le
    return {"messages": [response]}


def call_tools(state: AgentState) -> Dict[str, List[BaseMessage]]:
    """
    N≈ìud qui ex√©cute les outils appel√©s par le mod√®le.
    
    Args:
        state: √âtat actuel de l'agent
        
    Returns:
        Dictionnaire avec les messages des r√©sultats des outils
    """
    # R√©cup√©rer le dernier message (doit √™tre un AIMessage avec tool_calls)
    last_message = state["messages"][-1]
    
    if not isinstance(last_message, AIMessage) or not last_message.tool_calls:
        return {"messages": []}
    
    # R√©cup√©rer les outils disponibles
    tools_dict = get_tools_dict()
    tool_messages = []
    
    # Ex√©cuter chaque outil appel√©
    for tool_call in last_message.tool_calls:
        tool_name = tool_call["name"]
        
        if tool_name in tools_dict:
            tool = tools_dict[tool_name]
            try:
                # Invoquer l'outil avec ses arguments
                result = tool.invoke(tool_call["args"])
                
                # Cr√©er un ToolMessage avec le r√©sultat
                tool_message = ToolMessage(
                    content=str(result),
                    tool_call_id=tool_call["id"]
                )
                tool_messages.append(tool_message)
                
            except Exception as e:
                # En cas d'erreur, cr√©er un message d'erreur
                error_message = ToolMessage(
                    content=f"Erreur lors de l'ex√©cution de {tool_name}: {e}",
                    tool_call_id=tool_call["id"]
                )
                tool_messages.append(error_message)
        else:
            # Outil non trouv√©
            error_message = ToolMessage(
                content=f"Outil '{tool_name}' non disponible",
                tool_call_id=tool_call["id"]
            )
            tool_messages.append(error_message)
    
    return {"messages": tool_messages}


# =============================================================================
# FONCTIONS CONDITIONNELLES
# =============================================================================

def should_continue(state: AgentState) -> Literal["tools", "__end__"]:
    """
    D√©termine si l'agent doit continuer avec les outils ou terminer.
    
    Args:
        state: √âtat actuel de l'agent
        
    Returns:
        "tools" si des outils doivent √™tre ex√©cut√©s, "__end__" pour terminer
    """
    # R√©cup√©rer le dernier message
    last_message = state["messages"][-1]
    
    # Si c'est un AIMessage avec des appels d'outils, continuer
    if isinstance(last_message, AIMessage) and last_message.tool_calls:
        return "tools"
    
    # Sinon, terminer
    return "__end__"


# =============================================================================
# FONCTIONS UTILITAIRES
# =============================================================================

def validate_state(state: AgentState) -> bool:
    """
    Valide que l'√©tat de l'agent est correct.
    
    Args:
        state: √âtat √† valider
        
    Returns:
        True si l'√©tat est valide, False sinon
    """
    if not isinstance(state, dict):
        return False
    
    if "messages" not in state:
        return False
    
    if not isinstance(state["messages"], list):
        return False
    
    # V√©rifier que tous les √©l√©ments sont des BaseMessage
    for msg in state["messages"]:
        if not isinstance(msg, BaseMessage):
            return False
    
    return True


def get_last_ai_message(state: AgentState) -> AIMessage | None:
    """
    R√©cup√®re le dernier message AI de l'√©tat.
    
    Args:
        state: √âtat de l'agent
        
    Returns:
        Le dernier AIMessage ou None si aucun trouv√©
    """
    for message in reversed(state["messages"]):
        if isinstance(message, AIMessage):
            return message
    return None
</file>

<file path="src/regulai/tools.py">
"""
Outils pour interagir avec le serveur MCP L√©gifrance via HTTP.

Ce module contient la classe MCPClient pour la communication HTTP et les outils 
LangChain d√©cor√©s avec @tool pour l'int√©gration avec l'agent LangGraph.
"""

import httpx
from typing import List, Dict, Any, Optional
from langchain_core.tools import tool
from pydantic import BaseModel, Field

from .config import get_config


# =============================================================================
# SCH√âMAS PYDANTIC POUR VALIDATION DES ARGUMENTS
# =============================================================================

class SearchParams(BaseModel):
    """Param√®tres pour la recherche dans L√©gifrance."""
    query: str = Field(
        description="Requ√™te de recherche en fran√ßais (ex: 'cong√©s pay√©s', 'droit du travail')"
    )
    max_results: int = Field(
        default=10,
        description="Nombre maximum de r√©sultats √† retourner"
    )


class ArticleParams(BaseModel):
    """Param√®tres pour r√©cup√©rer un article sp√©cifique."""
    article_id: str = Field(
        description="Identifiant de l'article (ex: 'LEGIARTI000006900846' ou 'L3141-1')"
    )


class BrowseCodeParams(BaseModel):
    """Param√®tres pour naviguer dans un code juridique."""
    code_name: str = Field(
        description="Nom du code juridique (ex: 'Code du travail', 'Code civil')"
    )
    section: Optional[str] = Field(
        default=None,
        description="Section sp√©cifique √† explorer (optionnel)"
    )


# =============================================================================
# CLIENT MCP POUR COMMUNICATION HTTP
# =============================================================================

class MCPClient:
    """
    Client HTTP pour communiquer avec le serveur MCP L√©gifrance.
    
    Cette classe encapsule toute la logique de communication HTTP avec le serveur MCP,
    permettant d'abstraire les d√©tails du protocole MCP pour les outils.
    """
    
    def __init__(self, server_url: Optional[str] = None, timeout: Optional[int] = None):
        """
        Initialise le client MCP.
        
        Args:
            server_url: URL du serveur MCP (utilise la config par d√©faut si None)
            timeout: Timeout en secondes (utilise la config par d√©faut si None)
        """
        config = get_config()
        self.server_url = server_url or config.mcp_server_url
        self.timeout = timeout or config.mcp_timeout
    
    def call_tool(self, tool_name: str, tool_args: Dict[str, Any]) -> str:
        """
        Appelle un outil sur le serveur MCP via HTTP.
        
        Args:
            tool_name: Nom de l'outil MCP √† appeler
            tool_args: Arguments √† passer √† l'outil
        
        Returns:
            R√©ponse de l'outil sous forme de cha√Æne format√©e
            
        Raises:
            Exception: En cas d'erreur de communication ou de serveur
        """
        try:
            # Pr√©parer la requ√™te selon le format attendu par le serveur MCP
            payload = {
                "method": "tools/call",
                "params": {
                    "name": tool_name,
                    "arguments": tool_args
                }
            }
            
            # Faire la requ√™te HTTP au serveur MCP
            with httpx.Client(timeout=self.timeout) as client:
                response = client.post(
                    f"{self.server_url}/invoke",  # Point d'entr√©e principal du serveur
                    json=payload,
                    headers={"Content-Type": "application/json"}
                )
                
                if response.status_code == 200:
                    result = response.json()
                    return self._parse_mcp_response(result)
                else:
                    return self._handle_error_response(response)
                    
        except httpx.RequestError as e:
            return f"Erreur de connexion au serveur MCP ({self.server_url}): {e}"
        except Exception as e:
            return f"Erreur lors de l'appel de l'outil {tool_name}: {e}"
    
    def _parse_mcp_response(self, result: Dict[str, Any]) -> str:
        """
        Parse la r√©ponse du serveur MCP selon son format.
        
        Args:
            result: R√©ponse JSON du serveur MCP
            
        Returns:
            Contenu format√© de la r√©ponse
        """
        # Parser la r√©ponse MCP selon son format
        if "result" in result:
            content = result["result"]
            
            # Si la r√©ponse contient du contenu structur√©
            if isinstance(content, dict) and "content" in content:
                content_data = content["content"]
                
                # G√©rer les r√©ponses avec liste de contenus
                if isinstance(content_data, list) and len(content_data) > 0:
                    first_item = content_data[0]
                    if isinstance(first_item, dict) and "text" in first_item:
                        return first_item["text"]
                    else:
                        return str(first_item)
                else:
                    return str(content_data)
            else:
                return str(content)
        else:
            return f"R√©ponse inattendue du serveur MCP: {result}"
    
    def _handle_error_response(self, response: httpx.Response) -> str:
        """
        G√®re les r√©ponses d'erreur HTTP.
        
        Args:
            response: R√©ponse HTTP d'erreur
            
        Returns:
            Message d'erreur format√©
        """
        error_msg = f"Erreur HTTP {response.status_code}"
        try:
            error_detail = response.json()
            error_msg += f": {error_detail}"
        except:
            error_msg += f": {response.text}"
        return error_msg
    
    def test_connection(self) -> bool:
        """
        Teste la connexion au serveur MCP.
        
        Returns:
            True si la connexion fonctionne, False sinon
        """
        try:
            with httpx.Client(timeout=self.timeout) as client:
                response = client.get(f"{self.server_url}/health")
                return response.status_code == 200
        except:
            return False
    
    def get_server_info(self) -> Optional[Dict[str, Any]]:
        """
        R√©cup√®re les informations du serveur MCP.
        
        Returns:
            Informations du serveur ou None en cas d'erreur
        """
        try:
            with httpx.Client(timeout=self.timeout) as client:
                response = client.get(f"{self.server_url}/info")
                if response.status_code == 200:
                    return response.json()
        except:
            pass
        return None


# Instance globale du client MCP
_mcp_client: Optional[MCPClient] = None


def get_mcp_client() -> MCPClient:
    """
    R√©cup√®re l'instance globale du client MCP.
    
    Returns:
        Instance du client MCP
    """
    global _mcp_client
    if _mcp_client is None:
        _mcp_client = MCPClient()
    return _mcp_client


# =============================================================================
# OUTILS L√âGIFRANCE AVEC D√âCORATEUR @tool
# =============================================================================

@tool("search_legifrance", args_schema=SearchParams, parse_docstring=True)
def search_legifrance(query: str, max_results: int = 10) -> str:
    """
    Recherche des textes juridiques dans la base de donn√©es L√©gifrance.
    
    Cet outil permet de chercher des lois, d√©crets, codes, jurisprudence et autres 
    textes juridiques fran√ßais. Utilisez des termes de recherche en fran√ßais.
    
    Args:
        query: Requ√™te de recherche en fran√ßais (ex: "cong√©s pay√©s", "licenciement √©conomique")
        max_results: Nombre maximum de r√©sultats √† retourner (d√©faut: 10)
        
    Returns:
        Liste format√©e des textes juridiques trouv√©s avec leurs r√©f√©rences
    """
    client = get_mcp_client()
    return client.call_tool("search_legifrance", {
        "query": query,
        "max_results": max_results
    })


@tool("get_article", args_schema=ArticleParams, parse_docstring=True)  
def get_article(article_id: str) -> str:
    """
    R√©cup√®re le contenu complet d'un article juridique sp√©cifique.
    
    Permet d'obtenir le texte int√©gral d'un article de loi, de code ou de d√©cret
    √† partir de son identifiant L√©gifrance ou de sa r√©f√©rence standard.
    
    Args:
        article_id: Identifiant de l'article (ex: "LEGIARTI000006900846", "L3141-1", "R1234-5")
        
    Returns:
        Texte complet de l'article avec ses m√©tadonn√©es (version, dates, etc.)
    """
    client = get_mcp_client()
    return client.call_tool("get_article", {
        "article_id": article_id
    })


@tool("browse_code", args_schema=BrowseCodeParams, parse_docstring=True)
def browse_code(code_name: str, section: Optional[str] = None) -> str:
    """
    Navigate dans la structure hi√©rarchique d'un code juridique fran√ßais.
    
    Permet d'explorer l'organisation d'un code (livres, titres, chapitres, sections)
    et d'obtenir la liste des articles dans une section donn√©e.
    
    Args:
        code_name: Nom du code juridique (ex: "Code du travail", "Code civil", "Code p√©nal")
        section: Section sp√©cifique √† explorer (ex: "L3141", "Livre III", optionnel)
        
    Returns:
        Structure hi√©rarchique du code ou contenu de la section demand√©e
    """
    client = get_mcp_client()
    return client.call_tool("browse_code", {
        "code_name": code_name,
        "section": section
    })


# =============================================================================
# FONCTIONS UTILITAIRES
# =============================================================================

def get_available_tools() -> List:
    """
    Retourne la liste des outils disponibles pour l'agent.
    
    Returns:
        Liste des fonctions-outils d√©cor√©es avec @tool
    """
    return [search_legifrance, get_article, browse_code]


def test_mcp_connection() -> bool:
    """
    Teste la connexion au serveur MCP.
    
    Returns:
        True si la connexion fonctionne, False sinon
    """
    client = get_mcp_client()
    return client.test_connection()


def get_mcp_server_info() -> Optional[Dict[str, Any]]:
    """
    R√©cup√®re les informations du serveur MCP.
    
    Returns:
        Informations du serveur ou None en cas d'erreur
    """
    client = get_mcp_client()
    return client.get_server_info()
</file>

<file path="tests/__init__.py">
# Tests pour le package RegulAI
</file>

<file path="tests/conftest.py">
"""
Configuration pytest pour les tests RegulAI.

Ce fichier contient les fixtures communes et la configuration de test.
"""

import pytest
import os
import sys
from unittest.mock import Mock

# Ajouter le r√©pertoire src au PYTHONPATH
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "src"))

from regulai.config import RegulAIConfig


@pytest.fixture
def mock_config():
    """Fixture qui fournit une configuration mock√©e pour les tests."""
    config = RegulAIConfig(
        openai_api_key="test_key_123",
        mcp_server_url="http://localhost:8000",
        mcp_timeout=30,
        model_name="gpt-4o-mini",
        model_temperature=0.0,
        max_iterations=20,
        default_max_results=10,
        log_level="INFO"
    )
    return config


@pytest.fixture
def mock_mcp_client():
    """Fixture qui fournit un client MCP mock√©."""
    client = Mock()
    client.call_tool.return_value = "R√©ponse de test du serveur MCP"
    client.test_connection.return_value = True
    client.get_server_info.return_value = {"version": "1.0.0", "status": "running"}
    return client


@pytest.fixture
def mock_openai_response():
    """Fixture qui fournit une r√©ponse OpenAI mock√©e."""
    response = Mock()
    response.content = "R√©ponse de test de l'agent"
    response.tool_calls = []
    return response
</file>

<file path="tests/test_tools.py">
"""
Tests pour les outils RegulAI.

Ce module teste les fonctionnalit√©s des outils MCP et leur int√©gration LangChain.
"""

import pytest
from unittest.mock import patch, Mock
import os
import sys

# Ajouter le r√©pertoire src au PYTHONPATH
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "src"))

from regulai.tools import get_available_tools, MCPClient, search_legifrance


def test_get_available_tools():
    """Test que les outils sont correctement charg√©s."""
    tools = get_available_tools()
    
    assert len(tools) == 3
    tool_names = [tool.name for tool in tools]
    assert "search_legifrance" in tool_names
    assert "get_article" in tool_names
    assert "browse_code" in tool_names


def test_mcp_client_initialization():
    """Test l'initialisation du client MCP."""
    client = MCPClient("http://test:8000", 60)
    
    assert client.server_url == "http://test:8000"
    assert client.timeout == 60


def test_search_legifrance_tool_structure():
    """Test la structure de l'outil search_legifrance."""
    tools = get_available_tools()
    search_tool = next(tool for tool in tools if tool.name == "search_legifrance")
    
    assert search_tool.name == "search_legifrance"
    assert search_tool.description is not None
    assert "Recherche des textes juridiques" in search_tool.description
    
    # V√©rifier le sch√©ma d'arguments
    schema = search_tool.args_schema.model_json_schema()
    properties = schema.get("properties", {})
    assert "query" in properties
    assert "max_results" in properties


@patch('regulai.tools.get_mcp_client')
def test_search_legifrance_tool_call(mock_get_client):
    """Test l'appel de l'outil search_legifrance."""
    # Mock du client MCP
    mock_client = Mock()
    mock_client.call_tool.return_value = "R√©sultats de recherche mock√©s"
    mock_get_client.return_value = mock_client
    
    # Appeler l'outil directement avec invoke
    result = search_legifrance.invoke({"query": "test query", "max_results": 5})
    
    # V√©rifications
    assert result == "R√©sultats de recherche mock√©s"
    mock_client.call_tool.assert_called_once_with(
        "search_legifrance", 
        {"query": "test query", "max_results": 5}
    )


def test_mcp_client_parse_response():
    """Test le parsing des r√©ponses MCP."""
    client = MCPClient()
    
    # Test r√©ponse normale
    response = {
        "result": {
            "content": [
                {"text": "Contenu de test"}
            ]
        }
    }
    
    result = client._parse_mcp_response(response)
    assert result == "Contenu de test"
    
    # Test r√©ponse simple
    response_simple = {
        "result": "R√©ponse simple"
    }
    
    result_simple = client._parse_mcp_response(response_simple)
    assert result_simple == "R√©ponse simple"


@patch('httpx.Client')
def test_mcp_client_connection_test(mock_httpx_client):
    """Test la v√©rification de connexion MCP."""
    # Mock de la r√©ponse HTTP
    mock_response = Mock()
    mock_response.status_code = 200
    
    mock_session = Mock()
    mock_session.get.return_value = mock_response
    mock_session.__enter__.return_value = mock_session
    mock_session.__exit__.return_value = None
    
    mock_httpx_client.return_value = mock_session
    
    # Test de connexion
    client = MCPClient("http://test:8000")
    result = client.test_connection()
    
    assert result is True
    mock_session.get.assert_called_once_with("http://test:8000/health")
</file>

<file path="tools_validation_report.json">
{
  "timestamp": "True",
  "mcp_server_available": false,
  "tools_count": 3,
  "tools": [
    {
      "name": "search_legifrance",
      "description": "Param√®tres pour la recherche dans L√©gifrance.",
      "schema": {
        "properties": {
          "query": {
            "description": "Requ√™te de recherche en fran√ßais (ex: 'cong√©s pay√©s', 'droit du travail')",
            "title": "Query",
            "type": "string"
          },
          "max_results": {
            "default": 10,
            "description": "Nombre maximum de r√©sultats √† retourner",
            "title": "Max Results",
            "type": "integer"
          }
        },
        "required": [
          "query"
        ]
      }
    },
    {
      "name": "get_article",
      "description": "Param√®tres pour r√©cup√©rer un article sp√©cifique.",
      "schema": {
        "properties": {
          "article_id": {
            "description": "Identifiant de l'article (ex: 'LEGIARTI000006900846' ou 'L3141-1')",
            "title": "Article Id",
            "type": "string"
          }
        },
        "required": [
          "article_id"
        ]
      }
    },
    {
      "name": "browse_code",
      "description": "Param√®tres pour naviguer dans un code juridique.",
      "schema": {
        "properties": {
          "code_name": {
            "description": "Nom du code juridique (ex: 'Code du travail', 'Code civil')",
            "title": "Code Name",
            "type": "string"
          },
          "section": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "default": null,
            "description": "Section sp√©cifique √† explorer (optionnel)",
            "title": "Section"
          }
        },
        "required": [
          "code_name"
        ]
      }
    }
  ]
}
</file>

</files>

quand je fais les test √ßa me fait √ßa :
ssef@DESKTOP-3H2V8PT MINGW64 /c/Users/assef/Documents/RegulAI
$ python -m pytest tests/ -v
=========================================== test session starts ===========================================
platform win32 -- Python 3.12.6, pytest-8.4.0, pluggy-1.6.0 -- C:\Users\assef\Documents\RegulAI\.venv\Scripts\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\assef\Documents\RegulAI
configfile: pyproject.toml
plugins: anyio-4.9.0, langsmith-0.3.45, asyncio-1.0.0, mock-3.14.1
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 6 items                                                                                          

tests/test_tools.py::test_get_available_tools PASSED                                                 [ 16%]
tests/test_tools.py::test_mcp_client_initialization PASSED                                           [ 33%]
tests/test_tools.py::test_search_legifrance_tool_structure FAILED                                    [ 50%]
tests/test_tools.py::test_search_legifrance_tool_call PASSED                                         [ 66%]
tests/test_tools.py::test_mcp_client_parse_response PASSED                                           [ 83%]
tests/test_tools.py::test_mcp_client_connection_test FAILED                                          [100%]

================================================ FAILURES ================================================= 
__________________________________ test_search_legifrance_tool_structure __________________________________ 

    def test_search_legifrance_tool_structure():
        """Test la structure de l'outil search_legifrance."""
        tools = get_available_tools()
        search_tool = next(tool for tool in tools if tool.name == "search_legifrance")

        assert search_tool.name == "search_legifrance"
        assert search_tool.description is not None
>       assert "Recherche des textes juridiques" in search_tool.description
E       AssertionError: assert 'Recherche des textes juridiques' in 'Param√®tres pour la recherche dans L√©gifrance.'
E        +  where 'Param√®tres pour la recherche dans L√©gifrance.' = StructuredTool(name='search_legifrance', description='Param√®tres pour la recherche dans L√©gifrance.', args_schema=<class 'regulai.tools.SearchParams'>, func=<function search_legifrance at 0x000001E405F94220>).description

tests\test_tools.py:44: AssertionError
_____________________________________ test_mcp_client_connection_test _____________________________________ 

mock_httpx_client = <MagicMock name='Client' id='2078864324560'>

    @patch('httpx.Client')
    def test_mcp_client_connection_test(mock_httpx_client):
        """Test la v√©rification de connexion MCP."""
        # Mock de la r√©ponse HTTP
        mock_response = Mock()
        mock_response.status_code = 200

        mock_session = Mock()
        mock_session.get.return_value = mock_response
>       mock_session.__enter__.return_value = mock_session
        ^^^^^^^^^^^^^^^^^^^^^^

tests\test_tools.py:106:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock id='2078865285312'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

C:\Program Files\Python312\Lib\unittest\mock.py:660: AttributeError
========================================= short test summary info =========================================
FAILED tests/test_tools.py::test_search_legifrance_tool_structure - AssertionError: assert 'Recherche des textes juridiques' in 'Param√®tres pour la recherche dans L√©gifran...
FAILED tests/test_tools.py::test_mcp_client_connection_test - AttributeError: __enter__
======================================= 2 failed, 4 passed in 0.20s =======================================
(.venv)
assef@DESKTOP-3H2V8PT MINGW64 /c/Users/assef/Documents/RegulAI
$



Qu'est ce qu'il me reste √† faire ? 
Tu es un expert senior dev en Langgraph, Agent IA. A l'aide la documentation de Langgraph et de FastMCP, fais des prompts √† Cursor qui a en contexte mon projet et demande lui de chercher les docs n√©cessaires avec Context7. Tu peux d√©couper en plusieurs prompt si besoin. Ne fournis pas d'extraits de code.
